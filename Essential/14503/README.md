## 문제 요약
- 로봇 청소기의 좌표와 방의 상태가 주어졌을 때, 청소하는 영역의 개수 구하기
- 방의 크기는 N x M
- 방향은 동서남북
- 방의 상태가 0이면 청소되지 않은 칸, 1이면 벽
- 로봇청소기 작동 방식
  1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소
  2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
      - 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
      - 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
  3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
      - 반시계 방향으로 90도 회전한다.
      - 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
      - 1번으로 돌아간다.

## 문제 풀이
```
int[] dr = {-1, 0, 1, 0};
int[] dc = {0, 1, 0, -1};
```
- dr, dc를 로봇청소기가 현재 바라보는 방향과 일치하게 `0북 1동 2남 3서`로 정해둔다.

```
if (room[r][c] == 0) {
		room[r][c] = 2;
		answer++;
}
```
- 현재 칸이 0이면 청소되지 않은 칸이므로 해당 칸의 값을 청소했다는 의미로 2를 저장하고 청소 횟수를 1 증가

```
d = (d + 3) % 4; // 반시계 90도
int nr = r + dr[d];
int nc = c + dc[d];
if (nr >= 0 && nr < n && nc >= 0 && nc < m && room[nr][nc] == 0) {
  clean(nr, nc, d);
  return;
}
```
- 반시계방향으로 90도 회전하려면 위의 dr, dc 기준으로 방향을 회전시키고, 해당 방향으로 다음 좌표를 정한다.
- 다음 좌표의 값이 0이고 범위를 벗어나지 않는다면 clean(nr, nc, d)를 호출해서 위의 과정을 반복한다.

```
int nr = r + dr[(d + 2) % 4]; // 후진
int nc = c + dc[(d + 2) % 4];
if (nr >= 0 && nr < n && nc >= 0 && nc < m && room[nr][nc] != 1) {
  clean(nr, nc, d);
}
```
- 주변 4칸 모두 청소되지 않은 빈칸이 없다면, 후진하여 다음 좌표를 정한다
- 다음 좌표의 값이 1(벽)이 아니고 범위를 벗어나지 않는다면 바라보는 방향 그대로 clean(nr, nc, d)를 호출해서 위의 과정을 반복한다.
