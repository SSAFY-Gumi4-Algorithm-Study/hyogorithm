## 문제 요약
- N명의 사용자가 있고, 친구 관계는 트리 구조로 주어진다
- 어떤 사용자가 얼리어답터면 그 사용자와 연결된 모든 친구에게 정보가 전달된다
- 모든 친구 관계에 대해 u와 v 중 적어도 한 명은 얼리어답터여야 한다
- 얼리어답터의 최소 수 구하기

## 문제 풀이 - DP + DFS
### DP 정의
- `dp[u][0]` : u가 얼리어답터가 아닐 때, u의 서브트리에서 필요한 최소 얼리어답터 수
- `dp[u][1]` : u가 얼리어답터일 때, u의 서브트리에서 필요한 최소 얼리어답터 수

### 점화식
- `dp[u][0] += dp[v][1]`: u가 얼리어답터가 아니라면, 연결된 자식 v는 얼리어답터여야 한다
- `dp[u][1] += min(dp[v][0], dp[v][1])`: u가 얼리어답터면 자식 v는 상관없으므로 더 작은 값을 선택

```java
	static void dfs(int u, int p) {
        dp[u][0] = 0; // u가 얼리어답터가 아닐 때
        dp[u][1] = 1; // u가 얼리어답터일 때(자기 자신)

        for (int v : adj[u]) {
            if (v == p) continue;
            
            dfs(v, u);
            
            dp[u][0] += dp[v][1];
            dp[u][1] += Math.min(dp[v][0], dp[v][1]);
        }
    }
```
- u는 현재 노드, p는 부모 노드
- 인접리스트로 순회하되, `if v == p: continue`로 부모로 역회귀 방지 (없으면 무한 재귀)
- 재귀 호출로 자식부터 dp 값 채우기
  - 자식 값이 결정되어야 부모 값 계산 가능하기 때문
 
## 예시
<img width="1440" height="722" alt="image" src="https://github.com/user-attachments/assets/937ac496-c130-4e94-8646-4515ed46b101" />
